#!/usr/bin/env python

"""

NAME: 
      pspec_sim_test.py 
PURPOSE:
      -Tests correlation between maps generated by pspec_sim_v2.py
EXAMPLE CALL:
      ./pspec_sim_test.py --pspec pspec50lmax200 --nchan 50 --sdf 0.001
AUTHOR:
      Carina Cheng

"""

import aipy
import numpy
import pylab
import pyfits
import matplotlib.pyplot as plt
import optparse
import os, sys
import healpy
import scipy
from scipy.interpolate import interp1d
from scipy import integrate

o = optparse.OptionParser()
o.set_usage('fitstopng.py [options]')
o.set_description(__doc__)
o.add_option('--pspec', dest='pspec', default='pspec50lmax200',
             help='Directory where pspec images are contained.')
o.add_option('--nchan', dest='nchan', default=203, type='int',
             help='Number of channels in simulated data. Default is 203.')
o.add_option('--sfreq', dest='sfreq', default=0.1, type='float',
             help='Start frequency (GHz). Default is 0.1.')
o.add_option('--sdf', dest='sdf', default=0.1/203, type='float',
             help='Channel spacing (GHz).  Default is 0.1/203.')
o.add_option('--lmax', dest='lmax', default=5, type='int',
             help='Maximum l value. Default is 5.')
opts, args = o.parse_args(sys.argv[1:])

path = '/Users/carinacheng/capo/ctc/images/pspecs/' + opts.pspec

"""
###plot one pixel value vs. frequency of maps

fluxes = []
freqs = numpy.linspace(opts.sfreq,opts.sfreq+opts.sdf*opts.nchan,num=opts.nchan, endpoint=False) #array of frequencies

for root, dirs, filenames in os.walk(path):
    for f in filenames:
        if f[9:] == '.fits':
            img = aipy.map.Map(fromfits = path + '/' + f)
            flux_px = img.map.map[0:10] #first 10 pixel values
            fluxes.append(flux_px)

plt.plot(freqs, fluxes, 'k-')
plt.xlabel('frequency [GHz]')
plt.ylabel('pixel value')
plt.show()
"""

###get C_l estimators to compare with theoretical values

#cosmology parameters

nu21 = 1420.*10**6 #21cm frequency [Hz]
c = 3.*10**5 #[km/s]
H0 = 100 #69.7 #Hubble's constant [km/s/Mpc]
omg_m = 0.28 
omg_lambda = 0.72

#P_k function

def P_k(kmag, sigma=0.005, k0=0.01, k1=0.04):

    return kmag*0+1. #flat P(k)
    #return numpy.exp(-(kmag-k0)**2/(2*sigma**2)) 
    #return numpy.exp(-(kmag-k0)**2/(2*sigma**2))+numpy.exp(-(kmag-k1)**2/(2*sigma**2)) #2 Gaussians

#C_l function

def C_l(freq1, freq2, Pk_interp, l_vals): #freqs are entered in GHz
    
    f1 = freq1*10**9 #[Hz]
    f2 = freq2*10**9 #[Hz]
    z1 = (nu21/f1)-1
    z2 = (nu21/f2)-1

    one_over_Ez = lambda zprime:1/numpy.sqrt(omg_m*(1+zprime)**3+omg_lambda)
    Dc1 = (c/H0)*integrate.quad(one_over_Ez,0,z1)[0]
    Dc2 = (c/H0)*integrate.quad(one_over_Ez,0,z2)[0]

    C_ls = []

    for i in range(len(l_vals)):

        ans2=0
        for kk in range(len(k_data)):
            #val = (2/numpy.pi)*Pk_interp(k_data[kk])*(k_data[kk]**2)*scipy.special.sph_jn(l_vals[i],k_data[kk]*Dc1)[0][l_vals[i]]*scipy.special.sph_jn(l_vals[i],k_data[kk]*Dc2)[0][l_vals[i]]
            #ans2+=val

            J_sub = (1/2.)*(2*l_vals[i]+1)
            x1 = k_data[kk]*Dc1
            x2 = k_data[kk]*Dc2
            bessel1 = numpy.sqrt(numpy.pi/2)*scipy.special.jn(J_sub,x1)/(numpy.sqrt(x1))
            bessel2 = numpy.sqrt(numpy.pi/2)*scipy.special.jn(J_sub,x2)/(numpy.sqrt(x2))
            val = (2/numpy.pi)*Pk_interp(k_data[kk])*(k_data[kk]**2)*bessel1*bessel2
            ans2 += val
        ans2*=(k_data[1]-k_data[0])

        C_ls.append(ans2)

    return C_ls
"""
###if using P(k) function

k_data = numpy.arange(0.005,0.1,0.005) #actual data points
Pk_data = P_k(k_data)
Pk_interp = interp1d(k_data, Pk_data, kind='linear')

"""
###if using P(k) points

#delta_sq = numpy.array([0.9413099, 2.047375, 5.35123, 9.884925, 19.12472, 24.78529, 28.9412, 29.81639, 29.235, 29.36708, 34.75652, 54.99383, 87.24504])
#ks = numpy.array([0.0281599, 0.04730816, 0.06677343, 0.09664913, 0.144889, 0.21846043, 0.327466, 0.49140543, 0.73756543, 1.10653729, 1.65998857, 2.39712429, 3.13152])
#Pk_data = delta_sq*(2*numpy.pi**2)/(ks**3)

#Pk_interp = interp1d(ks, Pk_data, kind='linear')

k_data = numpy.arange(0.001,0.6,0.01) #edit this and make sure the range is larger than k-range used so that interpolation works
delta_sq = .000505
Pk_data = delta_sq*(2*numpy.pi**2)/(k_data**3)
Pk_interp = interp1d(k_data,Pk_data,kind='linear')


###start of checks

l_vals = numpy.arange(0,opts.lmax,1) 

FREQ1 = 0.15 #change these if needed
FREQ2 = 0.15

"""
#check single freq maps

Cl_th = C_l(FREQ1,FREQ1,Pk_interp,l_vals)

nums = numpy.arange(1,11,1) #number of maps made

avg_cls = numpy.zeros((1,opts.lmax)) 

for i in range(len(nums)):

    all_cls = []

    singlemap = aipy.map.Map(fromfits = '/Users/carinacheng/capo/ctc/images/test' + str(nums[i])+ '.fits')#path + '/pspec1001.fits', interp=True)
    alms = singlemap.to_alm(opts.lmax,opts.lmax,iter=1)

    for l in range(opts.lmax):

        prefactor = 1./(2*l+1)
        m = l
        cl = 0

        for j in range(2*l+1):

            if m >= 0:
                alm = numpy.abs((alms[l,m]))**2
                cl += alm
            else:
                alm = numpy.abs((numpy.conj(alms[l,-m])))**2
                cl += alm
            m -= 1

        cl = cl*prefactor
        all_cls.append(cl)

    avg_cls = numpy.add(numpy.array(avg_cls), numpy.array(all_cls))

ans= (numpy.array(avg_cls)/len(nums))[0]
errors = []

for i in range(len(ans)):

    error = numpy.sqrt(2./(len(nums)*(2*l_vals[i]+1)))*Cl_th[i]
    errors.append(error)

p1 ,= plt.plot(l_vals,numpy.array(Cl_th),'k.')
p2 = plt.errorbar(l_vals,ans,yerr=errors,fmt='.')
plt.title('Freq = 0.15GHz')
plt.xlabel('l')
plt.ylabel('C$_{l}$')
plt.legend([p1,p2],['theoretical','observed'])
plt.show()
"""
"""
#check correlated frequency maps

Cl_th = C_l(FREQ1,FREQ2,Pk_interp,l_vals)

nums = numpy.arange(1,21,1) #number of maps made of each freq

avg_cls = numpy.zeros((1,50))

for i in range(len(nums)):

    all_cls = []

    singlemap1 = aipy.map.Map(fromfits = path + '/pspec' + str(nums[i]) + '001.fits', interp=True)
    singlemap2 = aipy.map.Map(fromfits = path + '/pspec' + str(nums[i]) + '002.fits', interp=True)

    alms1 = singlemap1.to_alm(opts.lmax,opts.lmax)
    alms2 = singlemap2.to_alm(opts.lmax,opts.lmax)

    for l in range(opts.lmax):

        prefactor = 1./(2*l+1)
        m = l
        cl = 0

        for j in range(2*l+1):

            if m >= 0:
                alm1 = numpy.conj(alms1[l,m])
                alm2 = alms2[l,m]
                alm = alm1*alm2
                #alm = (alm1*alm2+numpy.conj(alm2)*numpy.conj(alm1))/2
                cl += alm
            else:
                alm1 = alms1[l,-m]
                alm2 = numpy.conj(alms2[l,-m])
                alm = alm1*alm2
                #alm = (alm1*alm2+numpy.conj(alm2)*numpy.conj(alm1))/2
                cl += alm
            m -= 1

        cl = cl*prefactor
        all_cls.append(cl)

    avg_cls = numpy.add(numpy.array(avg_cls), numpy.array(all_cls))

ans = (numpy.array(avg_cls)/len(nums))[0]
#print ans

errors = []

for i in range(len(ans)):

    error = numpy.sqrt(2./(len(nums)*(2*l_vals[i]+1)))*Cl_th[i]
    errors.append(error)

p1 ,= plt.plot(l_vals,Cl_th,'k.')
p2 = plt.errorbar(l_vals,numpy.real(ans),yerr=errors,fmt='.')
plt.title('Freqs = 0.1GHz & 0.149GHz')
plt.xlabel('l')
plt.ylabel('C$_{l}$')
plt.legend([p1,p2],['theoretical','observed'])
plt.show()
"""


###Check P(k) from maps

#box parameters

num_maps = opts.nchan

###VARIABLES TO EDIT
deltax = 103 #63 #103 #step size in real space [Mpc]    #when choosing these, delta*N < Dc_range_in_box
deltay = 103 #63 #103
deltaz = 6
Nx = 1 #15 #box size [pixels] #MUST BE ODD
Ny = 1 #15
Nz = 191 #19
###

Lx = Nx*deltax #size range in real space [Mpc]
Ly = Ny*deltay
Lz = Nz*deltaz

print 'real space volume [Mpc] =', Lx,'x',Ly,'x',Lz
print 'real space resolution [Mpc] =', deltax,'x',deltay,'x',deltaz

T_r = numpy.zeros((Nx,Ny,Nz))

#mapping Dcs to freqs

def D_c(freq):
    f = freq*10**9
    z = (nu21/f)-1
    one_over_Ez = lambda zprime:1/numpy.sqrt(omg_m*(1+zprime)**3+omg_lambda)
    Dc = (c/H0)*integrate.quad(one_over_Ez,0,z)[0]
    return Dc

def delta_freq(delta_Dc,z):
    return (delta_Dc*H0*nu21/c)*(numpy.sqrt(omg_m*(1+z)**3+omg_lambda))/(1+z)**2

freqs_range = numpy.arange(0.05,0.25,0.001)
Dcs = []
for i in range(len(freqs_range)):
    Dcs.append(D_c(freqs_range[i]))

freq_interp = interp1d(Dcs[::-1],freqs_range[::-1],kind='linear')

###VARIABLES TO EDIT
min_freq = 0.1 #0.14679803 
max_freq = 0.199 #0.1555 
###

max_Dc = D_c(min_freq)
min_Dc = D_c(max_freq)
#print min_Dc, max_Dc
min_z = (nu21/(min_freq*10**9))-1
max_z = (nu21/(max_freq*10**9))-1
#print min_z,max_z
Dc_range_in_box = max_Dc-min_Dc
print 'Dc range = ',Dc_range_in_box, ' Mpc'

Dc_center = ((max_Dc-min_Dc)/2.)+min_Dc
print 'Dc_center = ', Dc_center, ' Mpc'
f_center = freq_interp(Dc_center)
z_center = (nu21/(f_center*10**9))-1

#read in maps

print 'Reading in maps...'

freqs = numpy.round(numpy.linspace(opts.sfreq,opts.sfreq+opts.sdf*opts.nchan,num=opts.nchan, endpoint=False),decimals=3) #array of frequencies of maps
map_nums = numpy.arange(1,opts.nchan+1,1)
all_maps = []

"""
for f in range(len(map_nums)):

    print '   '+str(map_nums[f])+'/'+str(len(map_nums))
    img = aipy.map.Map(fromfits=path+'/pspec1'+("%03i" % map_nums[f])+'.fits')
    all_maps.append(img)
"""

#loop over box indices

print 'Filling cube...'

#testmap = aipy.map.Map(nside=512)

for i in range(Nx):
    print '   '+str(i+1)+'/'+str(Nx)
    for j in range(Ny):
        for k in range(Nz):
            print k
            #note: origin is in the center of the cube
            px_x = -(Nx-1)/2 + i #how many pixels to move by from origin
            px_y = -(Ny-1)/2 + j
            px_z = -(Nz-1)/2 + k
            delta_x = px_x*deltax #physical distance moved from origin
            delta_y = px_y*deltay
            delta_z = px_z*deltaz

            delta_xyz = numpy.sqrt(delta_x**2+delta_y**2+delta_z**2)    

            Dc = numpy.sqrt(Dc_center**2+delta_xyz**2-(2*Dc_center*(-delta_z)))
            #note: when delta_z is negative, looking at bottom half of cube

            delta_f = delta_freq(Dc-Dc_center,z_center) #[Hz]

            #f = numpy.round(f_center-delta_f*10**-9,decimals=3)
            f = f_center-delta_f*10**-9
            f_string = str(f)[:len(str(opts.sdf))] #interpolating between 2 freqs
            f_lower = float(f_string)
            f_upper = f_lower+opts.sdf
            phi = numpy.arctan2(delta_y,delta_x)
            theta = numpy.arccos((Dc_center+delta_z)/Dc)

            #print px_x, px_y, px_z, delta_x, delta_y, delta_z, f

            #map_num = int(((f-opts.sfreq)/opts.sdf)+1)
            #img = all_maps[map_num-1]
            #T_r[i][j][k] = img[theta,phi]
            map_num_lower = int(((f_lower-opts.sfreq)/opts.sdf)+1)
            map_num_upper = int(((f_upper-opts.sfreq)/opts.sdf)+1)
            #img_lower = all_maps[map_num_lower]#-1] #if maps are read and stored in loop above
            #img_upper = all_maps[map_num_upper]#-1]
            img_lower = aipy.map.Map(fromfits=path+'/pspec1'+("%03i" % (map_num_lower+1))+'.fits') #if too many maps to store
            img_upper = aipy.map.Map(fromfits=path+'/pspec1'+("%03i" % (map_num_upper+1))+'.fits')
            value_lower = img_lower[theta,phi]
            value_upper = img_upper[theta,phi]
            finterp = interp1d([f_lower,f_upper],[value_lower[0],value_upper[0]],kind='linear')
            T_r[i][j][k] = finterp(f)
 
#print T_r

numpy.save('Tr_test.npy',T_r)
T_r = numpy.load('Tr_test.npy')

#print T_r 

###plot slice of cube

slice = T_r[Nx/2]
plt.imshow(numpy.real(slice))
#plt.show()
otherslice = []
for i in T_r:
    otherslice.append(i[Ny/2])
plt.imshow(numpy.real(otherslice))
#plt.show()
otherslice2 = numpy.zeros_like(otherslice)
for i in range(len(T_r)):
    slice = T_r[i]
    for j in range(len(slice)):
        otherslice2[i][j] = slice[j][Nz/2]
plt.imshow(numpy.real(otherslice2))
#plt.show()


###recover P(k)
T_q = numpy.fft.fftn(T_r)
numpy.save('Tq_test.npy',T_q)
T_q = numpy.load('Tq_test.npy')
kx = numpy.fft.fftfreq(Nx,deltax)*2*numpy.pi 
ky = numpy.fft.fftfreq(Ny,deltay)*2*numpy.pi
kz = numpy.fft.fftfreq(Nz,deltaz)*2*numpy.pi
kx = kx.copy(); kx.shape = (kx.size,1,1)
ky = ky.copy(); ky.shape = (1,ky.size,1)
kz = kz.copy(); kz.shape = (1,1,kz.size)
k_cube = numpy.sqrt(kx**2+ky**2+kz**2)
#print kx,ky,kz
#ks = numpy.fft.fftfreq(N,delta)*2*numpy.pi #stores k's in 1D array

#T_tilde = T_q*delta**3
T_tilde = T_q*deltax*deltay*deltaz

#binning

k_sampling = 0.05
k_bins = numpy.arange(0,numpy.max(k_cube)+k_sampling,k_sampling)
num_bins = len(k_bins)-1
print num_bins
temp_squared = numpy.zeros(num_bins)
num_in_bins = numpy.zeros(num_bins)

#cutoff = numpy.max(ks) #edit this depending on what lmax is simulated up to

for i in range(Nx):
    for j in range(Ny):
        for k in range(Nz):
            k_val = k_cube[i][j][k]
            #if numpy.abs(ks[i]) < cutoff and numpy.abs(ks[j]) < cutoff:
            for b in range(num_bins):
                if k_val >= k_bins[b] and k_val < k_bins[b+1]:
                    temp_squared[b] += numpy.abs(T_tilde[i][j][k]*numpy.conj(T_tilde[i][j][k]))
                    num_in_bins[b] += 1

#Pk = (temp_squared/num_in_bins)/(delta*N)**3
Pk = (temp_squared/num_in_bins)/(deltax*Nx*deltay*Ny*deltaz*Nz)

print num_in_bins
#print Lx,Ly,Lz
plt.clf()

final_ks = []
print 'Sky Map P(k):'
for i in range(len(k_bins)-1):
    print k_bins[i],'<k<',k_bins[i+1],'   P(k)=',Pk[i]
    k = (k_bins[i+1]+k_bins[i])/2
    final_ks.append(k)
    y_err = numpy.sqrt(2/num_in_bins[i])*Pk_interp(k)
    #plt.errorbar((k_bins[i+1]+k_bins[i])/2,Pk[i],xerr=1/Lz,yerr=y_err,fmt='.')
    plt.errorbar((k_bins[i+1]+k_bins[i])/2,numpy.log10(Pk[i]),xerr=1/Lz,yerr=0.434*(y_err/Pk[i]),fmt='.')    #log plot on y-axis

print '['+','.join(map(str,final_ks))+']'
print '['+','.join(map(str,Pk*(1000**2)))+']'

#print 'Original P(k):'
#for i in range(len(k_data)):
    #print 'k=',("%0.5f" % k_data[i]),'   P(k)=', Pk_interp(k_data[i]) #Pk_data[i]
    #plt.plot(k_data[i],Pk_interp(k_data[i]),'k.')

print 'Original P(k):'
for i in range(len(k_bins)-1):
    k=(k_bins[i+1]+k_bins[i])/2
    print 'k=',k,'   P(k)=', Pk_interp(k)
    #plt.plot(k,Pk_interp(k),'k.')
    plt.plot(k,numpy.log10(Pk_interp(k)),'k.')    #log plot on y-axis

plt.show()


    

