# coding: utf-8
# don't ask me why the above line is here. I was getting a weird error saying
# that I was using a non-ascii character on line 11 and this fixed it.....
import aipy as a, numpy as n, pylab as p
import capo as C
import healpy as hp
import useful_functions as uf
import os,subprocess

# in gsm directory run
# $ gfortran -ffixed-line-length-none gsmmanyfreqs.f -o gsmmf.sh
# edit args.dat 
# put all the following on the first line: 
#   > the prefix of all the data files it will make,  
#   > the lowest frequency that you’d like to simulate (in MHz), 
#   > the frequency resolution (so the delta-nu between adjacent simulations), 
#   > the total number of frequencies you’d like to simulate.
# then run  
# $ ./gsmmf.sh
# it will put all the data files in the current directory
# next you need to convert the .dat files to .fits 
# you can run gsm_to_fits(filename.dat) individual file or loop over many
# files in a folder using gsm_to_fits_loop()
# to make a color map of the fits data, go to the terminal and do:
# $ plot_map.py '/Users/mpresley/soft/gsm/data_100MHz_150MHz/hi1001.fits'

def gsm_to_fits(filename):
    """
    Takes a .dat file from the global sky model and converts it to a .fits
    file in the same directory
    """
    dat = n.loadtxt(filename)
    heal = a.healpix.HealpixMap(nside=512)
    heal.map = dat
    heal.to_fits(filename.replace('.dat','.fits'))

def gsm_to_fits_loop(folderpath):
    """
    Loops over all .dat files in a folder and runs gsm_to_fits to convert them
    to a .fits file stored in the same location
    """
    for filename in os.listdir(folderpath):
        if '.dat' in filename:
            print filename
            gsm_to_fits(os.path.join(folderpath,filename))


def gsm_degrade_map():
    """
    This has a weird problem where I can't get the map to write out in the correct shape.
    Even though I explicitly 
    """
    # http://healpy.readthedocs.org/en/latest/generated/healpy.pixelfunc.ud_grade.html#healpy.pixelfunc.ud_grade
    nside=32
    healmap = a.map.Map(fromfits='/Users/mpresley/soft/gsm/data_100MHz_150MHz/hi1001.fits')
    data = healmap.map.map
    data2 = hp.ud_grade(data,nside,order_in='RING',order_out='RING')
    data2 = data2[0:12*nside*nside]
    newmap = a.map.Map()
    newmap.set_map(data2)
    newmap.to_fits('/Users/mpresley/soft/gsm/data_100MHz_150MHz/hi1001_32.fits',clobber=True)

def import_gsm_data(folderpath='/Users/mpresley/soft/gsm/data_100MHz_150MHz/',savedata=True):
    """
    Takes a folder containing the args.dat file used for gsmanyfreqs.f and the .fits 
    files generated by running gsmanyfreqs.f and gsm_to_fits_loop. 

    Returns a 2d array with the healpix data for different frequencies in the columns.
    Also returns a 1d array telling the frequency in MHz that corresponds to each column. 
    """
    ff = open(folderpath+'args.dat','r')
    args = ff.readline()
    datpre,nui,nustep,nunum = args.split(' ')
    nui=int(nui);nustep=int(nustep);nunum=int(nunum)
    freqs = n.linspace(nui,nunum*nustep+nui,num=nunum,endpoint=True)
    for ii in range(nunum):
        print ii
        healmap = a.map.Map(fromfits='{0}{1}{2}.fits'.format(folderpath,datpre,1001+ii))
        if ii==0:
            data = n.zeros([healmap.map.map.shape[0],nunum])
        data[:,ii] = healmap.map.map
    if savedata: n.savez_compressed(folderpath+'map_data',data=data,freqs=freqs)
    return data, freqs

def power_fit_gsm_data(data,freqs,savefolderpath=None):
    params = n.zeros([data.shape[0],3])
    for ii in range(data.shape[0]):
        print ii
        # amp        index           redchi
        params[ii,0], params[ii,1], _, _, params[ii,2] = uf.power_law_lstsq_fit(freqs,data[ii,:])
    if savefolderpath!=None: n.savez_compressed(savefolderpath+'power_fit_params',amp=params[:,0],index=params[:,1],redchi=params[:,2])
    return params

def map_spectral_index(index):
    indexmap = a.map.Map(nside=512)
    indexmap.map.map = index
    indexmap.to_fits('/Users/mpresley/soft/gsm/data_100MHz_150MHz/spectral_index.fits',clobber=True)
    subprocess.call(['plot_map.py','-m lin','/Users/mpresley/soft/gsm/data_100MHz_150MHz/spectral_index.fits'])

# make a healpix map 
#name = a.map.Map(fromfits='/Users/mpresley/soft/gsm/data_100MHz_150MHz/hi1001.fits')
# data component of map -- numpy array
#data = name.map.map

# pulls up healpix code in ipython
# aipy.healpix.HealpixMap??

#indexmap = a.map.Map
#indexmap.map.map = params[:,1]

def gsm_noise_covar_too_much_memory(baselines,aa,fq=0.1,
    gsm_data_file='/Users/mpresley/soft/gsm/data_100MHz_150MHz/hi1001.fits',
    savepath=None):
    """
    > aa is an antenna array.
    > baselines should be a 1d array of baselines from the array.
    > fq is the frequency in GHz

    Will return a noise covariance matrix in the Fourier space, which is an nxn array
    where n is the number of baselines.
    """

    # im = a.img.Img(size=200, res=.5) #make an image of the sky to get sky coords
 #    tx,ty,tz = im.get_top(center=(200,200)) #get coords of the zenith?
 #    valid = n.logical_not(tx.mask)
 #    tx,ty,tz = tx.flatten(),ty.flatten(),tz.flatten()
    healmap = a.map.Map(fromfits=gsm_data_file)
    px_array = n.arange(healmap.npix()) # gets an array of healpix pixel indices
    crd_array = n.array(healmap.px2crd(px_array,ncrd=3)) # finds the topocentric coords for each healpix pixel
    print crd_array.shape

    #beam response for an antenna pointing at crd with a polarization in x direction
    amp = aa[0].bm_response(crd_array,pol='x')**2 
    print amp.shape
    #array to convert healpix map to Fourier Space: rows baselines; cols pixels
    G = n.zeros([len(baselines),crd_array.shape[1]],dtype=n.complex)
    for ii in range(len(baselines)):
        bx,by,bz = baselines[ii]
        for jj in range(crd_array.shape[1]): 
            print ii,jj 
            rx,ry,rz = crd_array[:,jj]          
            G[ii,jj] = amp[0,jj]*n.exp(-2j*n.pi*fq*(bx*rx+by*ry+bz*rz))
    G = n.matrix(G)

    mapdata = healmap.map.map
    mapdata.shape = (n.prod(mapdata.shape),)
    Rfg = n.matrix(n.diag(mapdata))

    Nfg = n.dot(G,n.dot(Rfg,G.H))

    if savepath!=None: n.savez_compressed(savepath,baselines=baselines,Nfg=Nfg)

    return Nfg


def gsm_noise_covar_slower(baselines,aa,fq=0.1,
    gsm_data_file='/Users/mpresley/soft/gsm/data_100MHz_150MHz/hi1001.fits',
    savepath=None):
    """
    > aa is an antenna array.
    > baselines should be a 1d array of baselines from the array.
    > fq is the frequency in GHz

    Will return a noise covariance matrix in the Fourier space, which is an nxn array
    where n is the number of baselines.
    """

    # im = a.img.Img(size=200, res=.5) #make an image of the sky to get sky coords
 #    tx,ty,tz = im.get_top(center=(200,200)) #get coords of the zenith?
 #    valid = n.logical_not(tx.mask)
 #    tx,ty,tz = tx.flatten(),ty.flatten(),tz.flatten()
    healmap = a.map.Map(fromfits=gsm_data_file)
    px_array = n.arange(healmap.npix()) # gets an array of healpix pixel indices
    crd_array = n.array(healmap.px2crd(px_array,ncrd=3)) # finds the topocentric coords for each healpix pixel
    print crd_array.shape

    Rdata = healmap.map.map

    #beam response for an antenna pointing at crd with a polarization in x direction
    amp = aa[0].bm_response(crd_array,pol='x')**2 
    print amp.shape
    #array to convert healpix map to Fourier Space: rows baselines; cols pixels
    Nfg = n.zeros([len(baselines),len(baselines)],dtype=n.complex)
    for ii in range(len(baselines)):
        bix,biy,biz = baselines[ii,:]
        for jj in range(len(baselines)):
            print ii,jj
            bjx,bjy,bjz = baselines[jj,:]  
            for kk in px_array:
                rx,ry,rz = crd_array[:,kk]          
                Gik = amp[0,kk]*n.exp(-2j*n.pi*fq*(bix*rx+biy*ry+biz*rz))
                Gjk_star = n.conj(amp[0,kk]*n.exp(-2j*n.pi*fq*(bjx*rx+bjy*ry+bjz*rz)))
                Rkk = Rdata[kk]*Rdata[kk]
                Nfg[ii,jj] += Gik*Rkk*Gjk_star

    if savepath!=None: n.savez_compressed(savepath,baselines=baselines,Nfg=Nfg)

    return Nfg


def gsm_noise_covar(baselines,aa,fq=0.1,
    gsm_data_file='/Users/mpresley/soft/gsm/data_100MHz_150MHz/hi1001.fits',
    savepath=None):
    """
    > aa is an antenna array.
    > baselines should be a 1d array of baselines from the array.
    > fq is the frequency in GHz

    Will return a noise covariance matrix in the Fourier space, which is an nxn array
    where n is the number of baselines.
    """

    # im = a.img.Img(size=200, res=.5) #make an image of the sky to get sky coords
 #    tx,ty,tz = im.get_top(center=(200,200)) #get coords of the zenith?
 #    valid = n.logical_not(tx.mask)
 #    tx,ty,tz = tx.flatten(),ty.flatten(),tz.flatten()
    healmap = a.map.Map(fromfits=gsm_data_file)
    px_array = n.arange(healmap.npix()) # gets an array of healpix pixel indices
    crd_array = n.array(healmap.px2crd(px_array,ncrd=3)) # finds the topocentric coords for each healpix pixel
    print crd_array.shape

    Rdata = healmap.map.map

    #beam response for an antenna pointing at crd with a polarization in x direction
    amp = aa[0].bm_response(crd_array,pol='x')**2 
    print amp.shape
    #array to convert healpix map to Fourier Space: rows baselines; cols pixels
    Nfg = n.zeros([len(baselines),len(baselines)],dtype=n.complex)
    for ii in range(len(baselines)):
        bix,biy,biz = baselines[ii,:]
        for jj in range(ii):
            print ii,jj
            bjx,bjy,bjz = baselines[jj,:]  
            for kk in px_array:
                rx,ry,rz = crd_array[:,kk]          
                Gik = amp[0,kk]*n.exp(-2j*n.pi*fq*(bix*rx+biy*ry+biz*rz))
                Gjk_star = n.conj(amp[0,kk]*n.exp(-2j*n.pi*fq*(bjx*rx+bjy*ry+bjz*rz)))
                Rkk = Rdata[kk]*Rdata[kk]
                Nfg[ii,jj] += Gik*Rkk*Gjk_star
            Nfg[jj,ii] = n.conj(Nfg[ii,jj])

    if savepath!=None: n.savez_compressed(savepath,baselines=baselines,Nfg=Nfg)

    return Nfg

if __name__=='__main__':
    #filename = '/Users/mpresley/soft/gsm/data_100MHz_150MHz/hi1001.dat'
    #gsm_to_fits_loop('/Users/mpresley/soft/gsm/data_100MHz_150MHz/')
    #data,freqs = import_gsm_data()
    #p.plot(freqs,data[500,:])
    f = n.load('/Users/mpresley/soft/gsm/data_100MHz_150MHz/map_data.npz')
    data = f['data']
    freqs = f['freqs']
    params = power_fit_gsm_data(data,freqs,savefolderpath='/Users/mpresley/soft/gsm/data_100MHz_150MHz/')
    #params = n.load('/Users/mpresley/soft/gsm/data_100MHz_150MHz/power_fit_params.npz')
    #print params['index']
    #map_spectral_index(params['index'])
    #p.plot(range(params['index'].shape[0]),params['index'],c='b')
    #p.plot(range(params.shape[0]),params[:,2],c='g')
    #p.show()

    #n.savez('/Users/mpresley/soft/gsm/data_100MHz_150MHz/map_data',data=data,freqs=freqs)


