#! /usr/bin/env python
import aipy as a, numpy as n, pylab as p, optparse, sys, capo as C
#import _beamuv as beamuv
import beamuv

o = optparse.OptionParser()
o.add_option('-b','--beam',dest='beam',default=None,
    help='The beam npz file to use.')
o.add_option('-t','--text',dest='text',default=None,
    help='The text file of source fluxes to use.')
opts,args = o.parse_args(sys.argv[1:])

_coeffs = beamuv.coeffs_from_file(opts.beam)
beam = beamuv.BeamUV(_coeffs,.150,size=1000.,pol='y')

srctimes,srcfluxes,x,y,z = C.jcp.read_srcnpz(args, verbose=True)
for src in srcfluxes: srcfluxes[src] = n.mean(srcfluxes[src], axis=1)
srcs = srctimes.keys()

fluxes = n.loadtxt(opts.text,usecols=[2])
srcnames = n.loadtxt(opts.text,usecols=[1],dtype='string')
fluxdict = {}
for f,k in zip(fluxes,srcnames):
    fluxdict[k] = f

for k in srcs:
    track = []
    for ix,iy,iz in zip(x[k],y[k],z[k]):
        track.append(beam.response(n.array([ix]),n.array([iy]),n.array([iz]))**2)
    track = n.array(track) * fluxdict[k]

    if False:
        p.semilogy(srctimes[k],srcfluxes[k],',',label='data')
        p.semilogy(srctimes[k],track,',',label='prediction')
        p.legend()
        p.title(k)
        p.show()

    wgttrack = srcfluxes[k]/fluxdict[k]
    #var = (n.sum(wgttrack*(srcfluxes[k]-track)**2)) * (1/(n.sum(wgttrack)))
    var = (n.sum((wgttrack**2)*(srcfluxes[k]-track)**2)) * (1/(n.sum(wgttrack**2)))
    std = n.sqrt(var)
    print k, fluxdict[k], '+/-', std
